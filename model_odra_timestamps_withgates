{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "view-in-github"
   },
   "source": [
    "<a href=\"https://colab.research.google.com/github/Kolo-Naukowe-Axion/QC1/blob/main/quantum_classifier.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "8jLzI6vhj-pd"
   },
   "source": [
    "##Quantum Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "ReVDTmxqlXfC",
    "outputId": "9dd5aaa7-a35b-4f56-a8d5-74b75c686dd4"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Requirement already satisfied: qiskit in /home/maria/AXION/.venv/lib/python3.12/site-packages (1.2.4)\n",
      "Requirement already satisfied: qiskit_machine_learning in /home/maria/AXION/.venv/lib/python3.12/site-packages (0.8.4)\n",
      "Requirement already satisfied: rustworkx>=0.15.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from qiskit) (0.17.1)\n",
      "Requirement already satisfied: numpy<3,>=1.17 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from qiskit) (2.4.1)\n",
      "Requirement already satisfied: scipy>=1.5 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from qiskit) (1.15.3)\n",
      "Requirement already satisfied: sympy>=1.3 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from qiskit) (1.14.0)\n",
      "Requirement already satisfied: dill>=0.3 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from qiskit) (0.4.1)\n",
      "Requirement already satisfied: python-dateutil>=2.8.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from qiskit) (2.9.0.post0)\n",
      "Requirement already satisfied: stevedore>=3.0.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from qiskit) (5.6.0)\n",
      "Requirement already satisfied: typing-extensions in /home/maria/AXION/.venv/lib/python3.12/site-packages (from qiskit) (4.15.0)\n",
      "Requirement already satisfied: symengine<0.14,>=0.11 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from qiskit) (0.13.0)\n",
      "Requirement already satisfied: scikit-learn>=1.2 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from qiskit_machine_learning) (1.8.0)\n",
      "Requirement already satisfied: setuptools>=40.1 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from qiskit_machine_learning) (80.9.0)\n",
      "Requirement already satisfied: six>=1.5 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from python-dateutil>=2.8.0->qiskit) (1.16.0)\n",
      "Requirement already satisfied: joblib>=1.3.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from scikit-learn>=1.2->qiskit_machine_learning) (1.5.3)\n",
      "Requirement already satisfied: threadpoolctl>=3.2.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from scikit-learn>=1.2->qiskit_machine_learning) (3.6.0)\n",
      "Requirement already satisfied: mpmath<1.4,>=1.1.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from sympy>=1.3->qiskit) (1.3.0)\n",
      "Note: you may need to restart the kernel to use updated packages.\n",
      "Requirement already satisfied: ucimlrepo in /home/maria/AXION/.venv/lib/python3.12/site-packages (0.0.7)\n",
      "Requirement already satisfied: pandas>=1.0.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from ucimlrepo) (2.3.3)\n",
      "Requirement already satisfied: certifi>=2020.12.5 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from ucimlrepo) (2026.1.4)\n",
      "Requirement already satisfied: numpy>=1.26.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from pandas>=1.0.0->ucimlrepo) (2.4.1)\n",
      "Requirement already satisfied: python-dateutil>=2.8.2 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from pandas>=1.0.0->ucimlrepo) (2.9.0.post0)\n",
      "Requirement already satisfied: pytz>=2020.1 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from pandas>=1.0.0->ucimlrepo) (2025.2)\n",
      "Requirement already satisfied: tzdata>=2022.7 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from pandas>=1.0.0->ucimlrepo) (2025.3)\n",
      "Requirement already satisfied: six>=1.5 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from python-dateutil>=2.8.2->pandas>=1.0.0->ucimlrepo) (1.16.0)\n",
      "Note: you may need to restart the kernel to use updated packages.\n",
      "Requirement already satisfied: torch in /home/maria/AXION/.venv/lib/python3.12/site-packages (2.10.0)\n",
      "Requirement already satisfied: filelock in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (3.20.3)\n",
      "Requirement already satisfied: typing-extensions>=4.10.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (4.15.0)\n",
      "Requirement already satisfied: setuptools in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (80.9.0)\n",
      "Requirement already satisfied: sympy>=1.13.3 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (1.14.0)\n",
      "Requirement already satisfied: networkx>=2.5.1 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (3.6.1)\n",
      "Requirement already satisfied: jinja2 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (3.0.3)\n",
      "Requirement already satisfied: fsspec>=0.8.5 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (2026.1.0)\n",
      "Requirement already satisfied: cuda-bindings==12.9.4 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (12.9.4)\n",
      "Requirement already satisfied: nvidia-cuda-nvrtc-cu12==12.8.93 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (12.8.93)\n",
      "Requirement already satisfied: nvidia-cuda-runtime-cu12==12.8.90 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (12.8.90)\n",
      "Requirement already satisfied: nvidia-cuda-cupti-cu12==12.8.90 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (12.8.90)\n",
      "Requirement already satisfied: nvidia-cudnn-cu12==9.10.2.21 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (9.10.2.21)\n",
      "Requirement already satisfied: nvidia-cublas-cu12==12.8.4.1 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (12.8.4.1)\n",
      "Requirement already satisfied: nvidia-cufft-cu12==11.3.3.83 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (11.3.3.83)\n",
      "Requirement already satisfied: nvidia-curand-cu12==10.3.9.90 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (10.3.9.90)\n",
      "Requirement already satisfied: nvidia-cusolver-cu12==11.7.3.90 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (11.7.3.90)\n",
      "Requirement already satisfied: nvidia-cusparse-cu12==12.5.8.93 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (12.5.8.93)\n",
      "Requirement already satisfied: nvidia-cusparselt-cu12==0.7.1 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (0.7.1)\n",
      "Requirement already satisfied: nvidia-nccl-cu12==2.27.5 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (2.27.5)\n",
      "Requirement already satisfied: nvidia-nvshmem-cu12==3.4.5 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (3.4.5)\n",
      "Requirement already satisfied: nvidia-nvtx-cu12==12.8.90 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (12.8.90)\n",
      "Requirement already satisfied: nvidia-nvjitlink-cu12==12.8.93 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (12.8.93)\n",
      "Requirement already satisfied: nvidia-cufile-cu12==1.13.1.3 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (1.13.1.3)\n",
      "Requirement already satisfied: triton==3.6.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from torch) (3.6.0)\n",
      "Requirement already satisfied: cuda-pathfinder~=1.1 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from cuda-bindings==12.9.4->torch) (1.3.3)\n",
      "Requirement already satisfied: mpmath<1.4,>=1.1.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from sympy>=1.13.3->torch) (1.3.0)\n",
      "Requirement already satisfied: MarkupSafe>=2.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from jinja2->torch) (3.0.3)\n",
      "Note: you may need to restart the kernel to use updated packages.\n",
      "Requirement already satisfied: matplotlib in /home/maria/AXION/.venv/lib/python3.12/site-packages (3.10.8)\n",
      "Requirement already satisfied: contourpy>=1.0.1 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from matplotlib) (1.3.3)\n",
      "Requirement already satisfied: cycler>=0.10 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from matplotlib) (0.12.1)\n",
      "Requirement already satisfied: fonttools>=4.22.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from matplotlib) (4.61.1)\n",
      "Requirement already satisfied: kiwisolver>=1.3.1 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from matplotlib) (1.4.9)\n",
      "Requirement already satisfied: numpy>=1.23 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from matplotlib) (2.4.1)\n",
      "Requirement already satisfied: packaging>=20.0 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from matplotlib) (24.1)\n",
      "Requirement already satisfied: pillow>=8 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from matplotlib) (12.1.0)\n",
      "Requirement already satisfied: pyparsing>=3 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from matplotlib) (3.3.2)\n",
      "Requirement already satisfied: python-dateutil>=2.7 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from matplotlib) (2.9.0.post0)\n",
      "Requirement already satisfied: six>=1.5 in /home/maria/AXION/.venv/lib/python3.12/site-packages (from python-dateutil>=2.7->matplotlib) (1.16.0)\n",
      "Note: you may need to restart the kernel to use updated packages.\n"
     ]
    }
   ],
   "source": [
    "%pip install qiskit qiskit_machine_learning\n",
    "%pip install ucimlrepo\n",
    "%pip install torch\n",
    "%pip install matplotlib"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "id": "LKSJGRyG0ouM"
   },
   "outputs": [],
   "source": [
    "from qiskit import QuantumCircuit\n",
    "from qiskit.circuit import ParameterVector\n",
    "from qiskit.primitives import StatevectorEstimator\n",
    "from qiskit.quantum_info import SparsePauliOp\n",
    "from qiskit_machine_learning.gradients import ParamShiftEstimatorGradient\n",
    "from qiskit_machine_learning.connectors import TorchConnector\n",
    "from qiskit_machine_learning.neural_networks import EstimatorQNN\n",
    "import numpy as np\n",
    "import torch.nn as nn\n",
    "import torch\n",
    "from torch.utils.data import DataLoader, TensorDataset\n",
    "\n",
    "\n",
    "import sys          # Standard library module for system-specific parameters and functions\n",
    "import subprocess   # Standard library module for spawning new processes\n",
    "from sklearn.preprocessing import MinMaxScaler # Importuje MinMaxScaler do skalowania danych\n",
    "from sklearn.model_selection import train_test_split # Importuje train_test_split do podziału danych\n",
    "from ucimlrepo import fetch_ucirepo     # Importuje fetch_ucirepo do pobierania zestawów danych z UCI ML Repository\n",
    "from sklearn.utils import shuffle\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, f1_score, accuracy_score\n",
    "\n",
    "import sys\n",
    "import subprocess\n",
    "import numpy as np\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    "from ucimlrepo import fetch_ucirepo\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "id": "enUz4SJl6Fnh"
   },
   "outputs": [],
   "source": [
    "\n",
    "def ensure_package(pkg_name, import_name=None):\n",
    "    import_name = import_name or pkg_name\n",
    "    try:\n",
    "        __import__(import_name)\n",
    "    except ImportError:\n",
    "        subprocess.check_call([sys.executable, '-m', 'pip', 'install', pkg_name])\n",
    "\n",
    "# Ensure all requirements are met\n",
    "ensure_package('numpy')\n",
    "ensure_package('scikit-learn', 'sklearn')\n",
    "ensure_package('ucimlrepo')\n",
    "ensure_package('qiskit')\n",
    "\n",
    "def prepare_data():\n",
    "    \"\"\"\n",
    "    Fetches the banknote authentication dataset and returns scaled train/test splits.\n",
    "    Features are scaled to [0, pi] specifically for Angle Encoding.\n",
    "    \"\"\"\n",
    "    banknote_authentication = fetch_ucirepo(id=267)\n",
    "    X = banknote_authentication.data.features.to_numpy()\n",
    "    y = banknote_authentication.data.targets.to_numpy().ravel()\n",
    "\n",
    "    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n",
    "\n",
    "    # Scaling to [0, pi] ensures data maps perfectly to Ry rotation angles\n",
    "    scaler = MinMaxScaler(feature_range=(0, np.pi))\n",
    "    X_train_scaled = scaler.fit_transform(X_train)\n",
    "    X_test_scaled = scaler.transform(X_test)\n",
    "\n",
    "    return X_train_scaled, X_test_scaled, y_train, y_test\n",
    "\n",
    "\n",
    "# Global availability of data\n",
    "X_tr, X_te, y_tr, y_te = prepare_data()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "id": "Pz4kqrFfANdX"
   },
   "outputs": [],
   "source": [
    "def ansatz(n_qubits, depth):\n",
    "    \"\"\"\n",
    "    The code below constructs the ansatz. It is built using the Qiskit library\n",
    "    and utilizes its built-in tools, such as ParameterVector, to easily iterate\n",
    "    over rotation gate parameters.\n",
    "\n",
    "    The implementation assumes the use of 4 qubits and an even number of layers\n",
    "    (depth). Each layer consists of a sub-layer of independent gates and a\n",
    "    sub-layer of entanglement.\n",
    "    \"\"\"\n",
    "\n",
    "    # Create a vector of learnable parameters.\n",
    "    # Total parameters = 8 * depth (16 per full loop iteration).\n",
    "    theta = ParameterVector('θ', 8 * depth)\n",
    "    qc = QuantumCircuit(n_qubits)\n",
    "\n",
    "    # The loop iterates (depth // 2) times.\n",
    "    # This structure requires 'depth' to be even to execute full blocks.\n",
    "    for j in range(depth // 2):\n",
    "\n",
    "\n",
    "        # -------- Layer 1 --------\n",
    "\n",
    "        # --- Sub-layer: Independent RY rotations --\n",
    "        # Apply RY rotation to every qubit using the first set of parameters for this block.\n",
    "        for i in range(n_qubits):\n",
    "            qc.ry(theta[j * n_qubits * 4 + i], i)\n",
    "\n",
    "        # --- Sub-layer: Entanglement (CRX) ---\n",
    "        # Controlled-RX gates creating a specific ring topology.\n",
    "        qc.crx(theta[j * n_qubits * 4 + 4], 3, 0)\n",
    "        qc.crx(theta[j * n_qubits * 4 + 5], 2, 3)\n",
    "        qc.crx(theta[j * n_qubits * 4 + 6], 1, 2)\n",
    "        qc.crx(theta[j * n_qubits * 4 + 7], 0, 1)\n",
    "\n",
    "\n",
    "        # -------- Layer 2 --------\n",
    "\n",
    "        # --- Sub-layer: Independent RX rotations ---\n",
    "        # Apply RX rotation to every qubit using the second set of parameters (offset by 8).\n",
    "        for i in range(n_qubits):\n",
    "            qc.rx(theta[j * n_qubits * 4 + 8 + i], i)\n",
    "\n",
    "        # --- Sub-layer: Entanglement (CRY) ---\n",
    "        # Controlled-RY gates creating a different ring topology.\n",
    "        qc.cry(theta[j * n_qubits * 4 + 12], 3, 2)\n",
    "        qc.cry(theta[j * n_qubits * 4 + 13], 0, 3)\n",
    "        qc.cry(theta[j * n_qubits * 4 + 14], 1, 0)\n",
    "        qc.cry(theta[j * n_qubits * 4 + 15], 2, 1)\n",
    "\n",
    "    return qc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "from qiskit.primitives import PrimitiveResult, PubResult\n",
    "from qiskit.primitives.base import BaseEstimatorV2\n",
    "from qiskit.primitives.containers.data_bin import DataBin\n",
    "from qiskit import transpile\n",
    "import numpy as np\n",
    "\n",
    "class SimpleIQMJob:\n",
    "    \"\"\"A dummy job that simply holds the result.\"\"\"\n",
    "    def __init__(self, result):\n",
    "        self._result = result\n",
    "    \n",
    "    def result(self):\n",
    "        return self._result\n",
    "\n",
    "# --- THE BRIDGE CLASS ---\n",
    "class IQMBackendEstimator(BaseEstimatorV2):\n",
    "    def __init__(self, backend, options=None):\n",
    "        super().__init__()\n",
    "        self._backend = backend\n",
    "        self._options = options or {\"shots\": 100}\n",
    "\n",
    "    def run(self, pubs, precision=None):\n",
    "        if not isinstance(pubs, list): pubs = [pubs]\n",
    "        job_results = []\n",
    "        \n",
    "        # 1. Prepare Circuit\n",
    "        base_circuit = pubs[0][0]\n",
    "        circuit_with_meas = base_circuit.copy()\n",
    "        if circuit_with_meas.num_clbits == 0:\n",
    "            circuit_with_meas.measure_all()\n",
    "        \n",
    "        # 2. Transpile\n",
    "        transpiled_qc = transpile(circuit_with_meas, self._backend, optimization_level=3)\n",
    "        \n",
    "        for pub in pubs:\n",
    "            _, observables, parameter_values = pub\n",
    "            if parameter_values.ndim == 1:\n",
    "                parameter_values = [parameter_values]\n",
    "            \n",
    "            pub_expectations = []\n",
    "            \n",
    "            for params in parameter_values:\n",
    "                bound_qc = transpiled_qc.assign_parameters(params)\n",
    "                \n",
    "                # 3. Execute on Hardware\n",
    "                try:\n",
    "                    job = self._backend.run(bound_qc, shots=self._options[\"shots\"])\n",
    "                    result = job.result()\n",
    "                    counts = result.get_counts()\n",
    "                    \n",
    "                    if isinstance(counts, list): counts = counts[0]\n",
    "\n",
    "                    # 4. Calculate Expectation\n",
    "                    shots = sum(counts.values())\n",
    "                    count_0 = 0\n",
    "                    for bitstring, count in counts.items():\n",
    "                        if bitstring[-1] == '0':\n",
    "                            count_0 += count\n",
    "                    \n",
    "                    p0 = count_0 / shots\n",
    "                    p1 = 1 - p0\n",
    "                    pub_expectations.append(p0 - p1)\n",
    "\n",
    "                except Exception as e:\n",
    "                    print(f\"Job failed: {e}\")\n",
    "                    pub_expectations.append(0.0)\n",
    "            \n",
    "            data = DataBin(evs=np.array(pub_expectations), shape=(len(pub_expectations),))\n",
    "            job_results.append(PubResult(data=data))\n",
    "\n",
    "        return SimpleIQMJob(PrimitiveResult(job_results))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "id": "z_JEkN9KJ-Fh"
   },
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "    The code below constructs the class HybridModel. It is built using the Qiskit and Pytorch library and\n",
    "    and utilizes its built-in tools, to create a model connecting classical and quantum computing.\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "class HybridModel(nn.Module):\n",
    "    def __init__(self, ansatz_circuit, num_qubits):\n",
    "        super().__init__()\n",
    "        self.feature_map = self.angle_encoding(num_qubits)\n",
    "\n",
    "        # Connecting the quantum circuit. Connecting our feature map (data) and ansatz\n",
    "        self.qc = QuantumCircuit(num_qubits)\n",
    "        self.qc.compose(self.feature_map, qubits=range(num_qubits), inplace=True)\n",
    "        self.qc.compose(ansatz_circuit, inplace=True)\n",
    "\n",
    "        # Firstly, we inicialize parameters. Our quantum model cannot tell whether the number came from ansatz or feature.\n",
    "        # That is why here we sort them into two lists. If the number came from feature_map, then it will be a feature and the other way around.\n",
    "        input_params = list(self.feature_map.parameters)\n",
    "        weight_params = list(ansatz_circuit.parameters)\n",
    "\n",
    "        '''\n",
    "        Measure the Z-operator (spin) on the very first qubit (q_0) and ignore all the other qubits.\n",
    "        Qiskit reads the string in a reversed order, that is why the Z gate is on the end.\n",
    "        SparsePauliOp.from_list([(\"I\" * (num_qubits - 1) + \"Z\", 1)]) converts string into a mathematical matrix that Qiskit can use for calculations\n",
    "        Coefficient = 1 is a weight we multiply our result by. In QML it is mostly set to 1\n",
    "        '''\n",
    "\n",
    "        observable = SparsePauliOp.from_list([(\"I\" * (num_qubits - 1) + \"Z\", 1)])\n",
    "\n",
    "        # Estimator takes ansatz, observables and parameters (data and weights), returns the Expectation value.\n",
    "        # !!!! CHANGE WHEN USING ON QUANTUM COMPUTER\n",
    "        # Needed when running quantum simulations, it should be changed when implementing on real quantum computer\n",
    "        estimator = StatevectorEstimator()\n",
    "\n",
    "        # Compute the gradients of the sampling probability by the Parameter Shift Rule.\n",
    "        gradient = ParamShiftEstimatorGradient(estimator)\n",
    "\n",
    "\n",
    "        '''\n",
    "        The EstimatorQNN\n",
    "        This class from Qiskit Machine Learning is used to instantiate the quantum neural network.\n",
    "        It leverages the Qiskit Primitives (Estimator) to efficiently calculate expectation values\n",
    "        of the quantum circuit. This allows the model to output continuous, differentiable values (gradients)\n",
    "        required for backpropagation in hybrid quantum-classical training.\n",
    "        '''\n",
    "\n",
    "        self.qnn = EstimatorQNN(\n",
    "            circuit=self.qc,\n",
    "            observables=observable,\n",
    "            input_params=input_params,\n",
    "            weight_params=weight_params,\n",
    "            estimator=estimator,\n",
    "            gradient=gradient\n",
    "        )\n",
    "\n",
    "        '''\n",
    "        TORCH CONNECTOR\n",
    "        This line initializes the TorchConnector, which serves as a bridge between Qiskit and PyTorch. It wraps the Quantum Neural Network (QNN)\n",
    "        to make it function as a standard, differentiable PyTorch module (nn.Module).\n",
    "        This integration allows the quantum parameters to be optimized using standard PyTorch tools like\n",
    "        the Adam optimizer and automatic differentiation.\n",
    "        '''\n",
    "        self.quantum_layer = TorchConnector(self.qnn)\n",
    "\n",
    "        \"\"\"\n",
    "        Creates a Feature Map circuit using Angle Encoding. It maps classical input vectors\n",
    "        to the quantum space by applying Ry(theta) rotations on each qubit,\n",
    "        where the rotation angle theta corresponds to the input feature value.\n",
    "        This effectively encodes the data into the amplitudes of the quantum state\n",
    "        \"\"\"\n",
    "\n",
    "    def angle_encoding(self, num_qubits):\n",
    "        qc_data = QuantumCircuit(num_qubits)\n",
    "        input_params = ParameterVector('x', num_qubits)\n",
    "        for i in range(num_qubits):\n",
    "            qc_data.ry(input_params[i], i)\n",
    "        return qc_data\n",
    "\n",
    "    '''\n",
    "    This function acts as the main execution path. When the model receives data,\n",
    "    the forward function passes it into the quantum layer to be processed.\n",
    "    The quantum layer calculates the result based on the current circuit parameters and returns the prediction.\n",
    "    '''\n",
    "    def forward(self, x):\n",
    "        return self.quantum_layer(x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "dv_mmuC3lXfL",
    "outputId": "5db1ddd1-0af8-4896-e5e5-72b5d5e0e0fe"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Loading data...\n",
      "Data ready. Number of training samples: 1097\n"
     ]
    }
   ],
   "source": [
    "EPOCHS = 6\n",
    "BATCH_SIZE = 32\n",
    "LEARNING_RATE = 0.02\n",
    "\n",
    "train_loss_history = []\n",
    "test_loss_history = []\n",
    "acc_history = []\n",
    "\n",
    "print(\"Loading data...\")\n",
    "\n",
    "X_train, X_test, y_train_raw, y_test_raw = prepare_data()\n",
    "\n",
    "y_train = 2 * y_train_raw - 1\n",
    "y_test = 2 * y_test_raw - 1\n",
    "\n",
    "X_train = X_train.astype(np.float32)\n",
    "X_test = X_test.astype(np.float32)\n",
    "y_train = y_train.astype(np.float32)\n",
    "y_test = y_test.astype(np.float32)\n",
    "\n",
    "print(f\"Data ready. Number of training samples: {len(X_train)}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "id": "vbZY4sy_Dzuh"
   },
   "outputs": [],
   "source": [
    "# --- Preparing the DataLoader ---\n",
    "\n",
    "# Data conversion to tensors for PyTorch\n",
    "X_train_tensor = torch.tensor(X_train, dtype=torch.float32)\n",
    "y_train_tensor = torch.tensor(y_train, dtype=torch.float32).reshape(-1, 1)\n",
    "\n",
    "X_test_tensor = torch.tensor(X_test, dtype=torch.float32)\n",
    "y_test_tensor = torch.tensor(y_test, dtype=torch.float32).reshape(-1, 1)\n",
    "\n",
    "# Creating a dataset with X_train_tensor and Y_train_tensor\n",
    "train_dataset = TensorDataset(X_train_tensor, y_train_tensor)\n",
    "\n",
    "# Creating a DataLoader, which now automatically handles shuffle in the training loop\n",
    "train_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "PQpegINFKm1M",
    "outputId": "517e968a-f613-42a8-c11f-f359076be285"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Starting training... Epochs: 6\n",
      "Epoch 1/6 | Avg loss: 0.9160 | Test Acc: 0.8436\n",
      "Epoch 2/6 | Avg loss: 0.4094 | Test Acc: 0.8364\n",
      "Epoch 3/6 | Avg loss: 0.3969 | Test Acc: 0.8582\n",
      "Epoch 4/6 | Avg loss: 0.3932 | Test Acc: 0.8655\n",
      "Epoch 5/6 | Avg loss: 0.3882 | Test Acc: 0.8655\n",
      "Epoch 6/6 | Avg loss: 0.3895 | Test Acc: 0.8655\n"
     ]
    }
   ],
   "source": [
    "# Defining a loss function (note for Axion, it it the same as Michał calculated manually with diff**2)\n",
    "loss_function = torch.nn.MSELoss()\n",
    "\n",
    "# Inicializing the model\n",
    "final_ansatz = ansatz(4, 2)\n",
    "model = HybridModel(final_ansatz, 4)\n",
    "\n",
    "# Initializing the ADAM optimizer\n",
    "# Now that Our HybridModel is written in Pytorch, optimizer can access the paramiters directly\n",
    "optimizer = torch.optim.Adam(model.parameters(), lr=LEARNING_RATE)\n",
    "\n",
    "print(f\"Starting training... Epochs: {EPOCHS}\")\n",
    "\n",
    "for epoch in range(EPOCHS):\n",
    "    model.train()\n",
    "    epoch_loss = 0.0\n",
    "    batches_count = 0\n",
    "\n",
    "    for X_batch, y_batch in train_loader:\n",
    "\n",
    "        optimizer.zero_grad()           # Reset gradients\n",
    "        output = model(X_batch)         # Forward\n",
    "        loss = loss_function(output, y_batch) # Loss\n",
    "        loss.backward()                 # Backward\n",
    "        optimizer.step()                # Update weights\n",
    "\n",
    "        epoch_loss += loss.item()\n",
    "        batches_count += 1\n",
    "\n",
    "    # Evaluation on tensors\n",
    "    with torch.no_grad(): # To test our model we turn off the gradients\n",
    "\n",
    "        test_outputs = model(X_test_tensor)\n",
    "        test_loss = loss_function(test_outputs, y_test_tensor).item()\n",
    "\n",
    "        # Calculating accuracy:\n",
    "        # test.outputs > 0 returns True or False, by using float() we convert bools to 1.0 and 0.0\n",
    "        # Then, multiply it by two, so for True = 2.0 False = 0.0\n",
    "        # Substract 1 and the labels are either 1.0 or -1.0\n",
    "        predicted = (test_outputs > 0).float() * 2 - 1\n",
    "        correct = (predicted == y_test_tensor).sum().item()\n",
    "        test_accuracy = correct / len(y_test_tensor)\n",
    "\n",
    "    avg_loss = epoch_loss / batches_count\n",
    "    train_loss_history.append(avg_loss)\n",
    "    test_loss_history.append(test_loss)\n",
    "    acc_history.append(test_accuracy)\n",
    "\n",
    "    print(f\"Epoch {epoch+1}/{EPOCHS} | Avg loss: {avg_loss:.4f} | Test Acc: {test_accuracy:.4f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'model' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mNameError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[9]\u001b[39m\u001b[32m, line 2\u001b[39m\n\u001b[32m      1\u001b[39m FILE_PATH = \u001b[33m\"\u001b[39m\u001b[33mtrained_hybrid_model.pth\u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m----> \u001b[39m\u001b[32m2\u001b[39m torch.save(\u001b[43mmodel\u001b[49m.state_dict(), FILE_PATH)\n\u001b[32m      3\u001b[39m \u001b[38;5;28mprint\u001b[39m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mModel weights saved successfully to \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mFILE_PATH\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m)\n",
      "\u001b[31mNameError\u001b[39m: name 'model' is not defined"
     ]
    }
   ],
   "source": [
    "FILE_PATH = \"trained_hybrid_model.pth\"\n",
    "torch.save(model.state_dict(), FILE_PATH)\n",
    "print(f\"Model weights saved successfully to {FILE_PATH}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Weights loaded successfully! You can now proceed to hardware testing.\n"
     ]
    }
   ],
   "source": [
    "final_ansatz = ansatz(4, 2)\n",
    "model = HybridModel(final_ansatz, 4)\n",
    "\n",
    "try:\n",
    "    model.load_state_dict(torch.load(\"trained_hybrid_model.pth\"))\n",
    "    model.eval()\n",
    "    print(\"Weights loaded successfully! You can now proceed to hardware testing.\")\n",
    "except FileNotFoundError:\n",
    "    print(\"Error: The weights file was not found. Did you save it?\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 942
    },
    "id": "VKpTxQgZdUGC",
    "outputId": "b71de7d8-bb5d-444f-839c-2e5a6c47bb9c"
   },
   "outputs": [
    {
     "data": {
      "image/png": "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2SOn06nbbrvNa4EBAHAmqqiocNtqampOedyll16q9evX64svvpAkffTRR9q8ebOGDBkiSSosLFRxcbHS0tJc58TExKh///7aunWrV2P2uLLfuHGjtmzZoi5durjGunTpoieffFJXXHGFV4MDAMBrzC6y+/HcpKQkt+G5c+dq3rx5DQ6fNWuWKioq1LVrVwUHB8vhcOi+++5Tenq6JKm4uFiSFB8f73ZefHy8a5+3eJzsk5KSTvnwHIfDocTERK8EBQCAt9mM+s3M+ZJUVFQku93uGg8LCzvl8a+99ppWrlypVatWqUePHtq9e7emTJmixMREZWRkND2QJvC4jf/www9r0qRJ2rlzp2ts586duuuuu/TII494NTgAALzGSy/Csdvtbtvpkv306dM1a9YsjRkzRj179tTNN9+sqVOnKicnR5KUkJAgSSopKXE7r6SkxLXPWxpV2bdp00Y2239aH1VVVerfv79CQupPr6urU0hIiG699VaNGDHCqwECAOCPjh07pqAg95o6ODhYTqdTkpSSkqKEhAStX79evXv3llS/HmD79u264447vBpLo5L9okWLvPqlAAC0OC/N2TfWsGHDdN999yk5OVk9evTQhx9+qMcee0y33nqrJMlms2nKlClauHChzjvvPNetd4mJiV4vnBuV7Ft6bgEAAK9r4VvvnnzySWVnZ+vOO+9UaWmpEhMT9cc//lFz5sxxHTNjxgxVVVVpwoQJKi8v1+WXX661a9d69R57SbIZRtMfMVBdXa0TJ064jf33ooXmVlFRoZiYGH3/xTmyRzfpYYDAGW9wYm9fhwA0mzqjVu/p7zp69Giz5Y+TuSLpsXsVFNH0JOo8Xq2irOxmjbW5eJwhq6qqlJmZqXbt2ikyMlJt2rRx2wAAOCN5aYGeP/I42c+YMUMbNmzQkiVLFBYWpueff17z589XYmKiVqxY0RwxAgBgnoWTvcf32b/55ptasWKFBgwYoLFjx+qKK65Q586d1alTJ61cudL1sAAAAHBm8LiyLysr0znnnCOpfn6+rKxMknT55Zdr06ZN3o0OAABv4RW3jXfOOeeosLBQktS1a1e99tprkuor/pMvxgEA4Exz8gl6ZjZ/5XGyHzt2rD766CNJ9c/9zc3NVXh4uKZOnarp06d7PUAAAGCOx3P2U6dOdf3vtLQ0ff7558rPz1fnzp114YUX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ON577z3ZbDaVl5ef9hibzaa8vLxGX3PevHnq3bu3qbi++uor2Ww27d6929R1ADQdyR4B6ZZbbpHNZpPNZlNoaKg6d+6sBQsWqK6urtm/+/XXX9e9997bqGMbk6ABwCyejY+Adc0112jZsmWqqanR22+/rYkTJ6pVq1aaPXt2g2NPnDih0NBQr3xvXFycV64DAN5CZY+AFRYWpoSEBHXq1El33HGH0tLS9MYbb0j6T+v9vvvuU2Jiorp06SJJKioq0ujRoxUbG6u4uDgNHz5cX331leuaDodDWVlZio2NVdu2bTVjxgz99InTP23j19TUaObMmUpKSlJYWJg6d+6sF154QV999ZXreext2rSRzWbTLbfcIqn+rYI5OTlKSUlRRESEevXqpb/+9a9u3/P222/r/PPPV0REhAYOHOgWZ2PNnDlT559/vlq3bq1zzjlH2dnZqq2tbXDcM888o6SkJLVu3VqjR4/W0aNH3fY///zz6tatm8LDw9W1a1c9/fTTHscCoPmQ7GEZEREROnHihOvz+vXrVVBQoHXr1mnNmjWqra3V4MGDFR0drffff1//+te/FBUVpWuuucZ13qOPPqrly5frxRdf1ObNm1VWVqbVq1f/7Pf+4Q9/0J///GctXrxYe/bs0TPPPKOoqCglJSXpb3/7mySpoKBAR44c0RNPPCFJysnJ0YoVK7R06VJ9+umnmjp1qm666SZt3LhRUv0fJSNHjtSwYcO0e/du3XbbbZo1a5bH/02io6O1fPlyffbZZ3riiSf03HPP6fHHH3c7Zt++fXrttdf05ptvau3atfrwww915513uvavXLlSc+bM0X333ac9e/bo/vvvV3Z2tl566SWP4wHQTAwgAGVkZBjDhw83DMMwnE6nsW7dOiMsLMyYNm2aa398fLxRU1PjOufll182unTpYjidTtdYTU2NERERYbzzzjuGYRhG+/btjYceesi1v7a21ujYsaPruwzDMK666irjrrvuMgzDMAoKCgxJxrp1604Z57vvvmtIMr7//nvXWHV1tdG6dWtjy5YtbseOGzfOuPHGGw3DMIzZs2cb3bt3d9s/c+bMBtf6KUnG6tWrT7v/4YcfNvr27ev6PHfuXCM4ONg4ePCga+wf//iHERQUZBw5csQwDMM499xzjVWrVrld59577zVSU1MNwzCMwsJCQ5Lx4YcfnvZ7ATQv5uwRsNasWaOoqCjV1tbK6XTq97//vebNm+fa37NnT7d5+o8++kj79u1TdHS023Wqq6u1f/9+HT16VEeOHHF7rW9ISIj69evXoJV/0u7duxUcHKyrrrqq0XHv27dPx44d029/+1u38RMnTqhPnz6SpD179jR4vXBqamqjv+OkV199VYsXL9b+/ftVWVmpuro62e12t2OSk5PVoUMHt+9xOp0qKChQdHS09u/fr3Hjxmn8+PGuY+rq6hQTE+NxPACaB8keAWvgwIFasmSJQkNDlZiYqJAQ91/3yMhIt8+VlZXq27evVq5c2eBav/rVr5oUQ0REhMfnVFZWSpLeeusttyQr1a9D8JatW7cqPT1d8+fP1+DBgxUTE6NXXnlFjz76qMexPvfccw3++AgODvZarADMIdkjYEVGRqpz586NPv6iiy7Sq6++qnbt2jWobk9q3769tm/friuvvFJSfQWbn5+viy666JTH9+zZU06nUxs3blRaWlqD/Sc7Cw6HwzXWvXt3hYWF6cCBA6ftCHTr1s212PCkbdu2/fIP+V+2bNmiTp066e6773aNff311w2OO3DggA4fPqzExETX9wQFBalLly6Kj49XYmKivvzyS6Wnp3v0/QBaDgv0gB+lp6frrLPO0vDhw/X++++rsLBQ7733niZPnqyDBw9Kku666y498MADysvL0+eff64777zzZ++RP/vss5WRkaFbb71VeXl5rmu+9tprkqROnTrJZrNpzZo1+uabb1RZWano6GhNmzZNU6dO1UsvvaT9+/dr165devLJJ12L3m6//Xbt3btX06dPV0FBgVatWqXly5d79POed955OnDggF555RXt379fixcvPuViw/DwcGVkZOijjz7S+++/r8mTJ2v06NFKSEiQJM2fP185OTlavHixvvjiC3388cdatmyZHnvsMY/iAdB8SPbAj1q3bq1NmzYpOTlZI0eOVLdu3TRu3DhVV1e7Kv0//elPuvnmm5WRkaHU1FRFR0frhhtu+NnrLlmyRL/73e905513qmvXrho/fryqqqokSR06dND8+fM1a9YsxcfHKzMzU5J07733Kjs7Wzk5OerWrZuuueYavfXWW0pJSZFUP4/+t7/9TXl5eerVq5eWLl2q+++/36Of9/rrr9fUqVOVmZmp3r17a8uWLcrOzm5wXOfOnTVy5EgNHTpUgwYN0oUXXuh2a91tt92m559/XsuWLVPPnj111VVXafny5a5YAfiezTjdyiIAABAQqOwBAAhwJHsAAAIcyR4AgABHsgcAIMCR7AEACHAkewAAAhzJHgCAAEeyBwAgwJHsAQAIcCR7AAACHMkeAIAAR7IHACDA/T/jN25lyQYwLwAAAABJRU5ErkJggg==",
      "text/plain": [
       "<Figure size 640x480 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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N26UJCUlJSkyMlKJiYl68cUXFRwcrD///FPffPONLly4IH9//7vmAACAB8GcOXPUtm1beXh4qEuXLpoxY4Y2b95s81X2zLyHpqSk6IknntDKlSvVuXNnvfTSS7p06ZJiY2O1Z8+eNA2YzLhx44YiIyNVr149jR8/3vqB2sKFC3X16lW98MILypcvnzZt2qSpU6fqjz/+0MKFC63779q1S/Xr15e7u7v69u2r4sWL6/Dhw/r666/19ttvq1GjRipSpIjmzJmjNm3apMlLqVKlMvz6/tdffy0vLy917Ngx3e0lSpRQvXr1tGrVKl27dk3VqlVTyZIltWDBAnXv3t1m7vz585UnTx5FRkZKkk6fPq1atWpZP3ALDAzUd999p969eyshIUEvv/yyzf6jR4+Wh4eHXn31VSUmJsrDwyPD3F6/fj3dWszPz89m37///luPPfaYOnbsqC5dumjBggV64YUX5OHhoV69ekmSrl27pkaNGum3335TdHS0SpQooYULF6pHjx66cOGCXnrpJevr9e7dW7Nnz1aLFi307LPP6saNG1q7dq02bNigatWqWef98ssvWrx4sfr16ydfX19NmTJF7dq10/Hjx5UvXz5J0vPPP69FixYpOjpa5cqV019//aVffvlF+/fvV5UqVTI8f8ChDAAPrVmzZhmSjM2bN99xTuvWrQ0PDw/j8OHD1rGTJ08avr6+RoMGDaxjFStWNB5//PE7vs7ff/9tSDLGjRt3TzHu2LHDkGS89NJLGc579NFHjbx581qf165d26hatarNnE2bNhmSjM8//9wwDMNITU01QkNDjcjISCM1NdU67+rVq0aJEiWMZs2aWceGDx9uSDK6dOmSqbhXr15tSLrj49SpU9a5t8a2bNliHTt27Jjh5eVltGnTxjqW2Z/FsGHDDEnG4sWL08R16zxvxRcWFmYkJiZat0+ePNmQZOzevdswDMPYvn27IclYuHBhps4bAIAH0ZYtWwxJRmxsrGEYN98PCxcunKa+yMx76MyZMw1JxsSJE+8459b77OrVq222HzlyxJBkzJo1yzrWvXt3Q5Lx+uuvp3m9q1evphkbM2aMYbFYjGPHjlnHGjRoYPj6+tqM/TMewzCMwYMHG56ensaFCxesY2fOnDHc3NyM4cOHpznOPwUEBBgVK1bMcM6AAQMMScauXbusx3N3dzfOnz9vnZOYmGgEBAQYvXr1so717t3bKFiwoHHu3Dmb1+vcubPh7+9vzcGtnJYsWTLdvKQno1rsyy+/tM5r2LChIcmYMGGCTayVKlUyChQoYCQlJRmGYRiTJk0yJBlffPGFdV5SUpJRu3ZtI3fu3EZCQoJhGIaxatUqQ5IxYMCANDH982ciyfDw8DB+++0369jOnTsNScbUqVOtY/7+/kb//v0zdc6AM/EVOQB3lJKSoh9//FGtW7dWyZIlreMFCxbUU089pV9++cV6WXJAQID27t2rQ4cOpfta3t7e8vDw0E8//WTz9bS7uXTpkiTJ19c3w3m+vr42l0h36tRJW7dutV6qLt38xMzT01OtWrWSJO3YsUOHDh3SU089pb/++kvnzp3TuXPndOXKFTVt2lRr1qxRamqqzXHu9Y4jw4YNU2xsbJpH3rx5bebVrl1bVatWtT4vWrSoWrVqpR9++EEpKSn39LP46quvVLFixTSfUEqyuWpKknr27Gnz6V39+vUlSb///rskWa9Q+uGHH3T16tV7OncAAB4Uc+bMUVBQkBo3bizp5vthp06dNG/ePKWkpFjnZeY99KuvvlL+/PnTXdD69vfZe/HCCy+kGfP29rb++8qVKzp37pzq1KkjwzC0fft2SdLZs2e1Zs0a9erVS0WLFr1jPN26dVNiYqIWLVpkHZs/f75u3Lhx1zWKLl26lKlaTJK1HunUqZOSk5O1ePFi65wff/xRFy5cUKdOnSRJhmHoq6++UsuWLWUYhrUWO3funCIjI3Xx4sU0XwPr3r27TV7uplWrVunWYrd+F25xc3PTc889Z33u4eGh5557TmfOnNHWrVslScuXL1dwcLC6dOlinefu7q4BAwbo8uXL+vnnnyXd/B2xWCzprvF1++9IRESEzVVvjz76qPz8/Ky1mHSzzt64caNOnjyZ6fMGnIEGE4A7Onv2rK5evaoyZcqk2RYWFqbU1FSdOHFCkjRq1ChduHBBpUuXVnh4uAYNGqRdu3ZZ53t6eurdd9/Vd999p6CgIDVo0EBjx45VfHx8hjHcKlZuNZru5PbCp0OHDnJxcdH8+fMl3SxgFi5caF2/SJK1Gda9e3cFBgbaPD755BMlJiamWWfoTl/Tu5Pw8HBFRESkedx+OXdoaGiafUuXLq2rV6/q7Nmz9/SzOHz4sPVrdXdzeyF666uDt5qAJUqUUExMjD755BPlz59fkZGRmj59OusvAQCyjZSUFM2bN0+NGzfWkSNH9Ntvv+m3335TzZo1dfr0aa1cudI6NzPvoYcPH1aZMmXk5pZ1q424ubmpcOHCacaPHz+uHj16KG/evMqdO7cCAwPVsGFDSbK+F99qRNwt7rJly6p69eo2a0/NmTNHtWrVuuvd9Hx9fTNVi92aK0kVK1ZU2bJlrbWYdLOhlT9/fjVp0kTSzVrzwoUL+uijj9LUYj179pR0c82jf7rXWqxw4cLp1mJBQUE280JCQtIsrH7rTnO31gs9duyYQkND0ywqHhYWZt0u3fwdCQkJSfOBYnpur8Wkm/XYPz+QHTt2rPbs2aMiRYqoRo0aGjFihE0DCnhQ0GACkCUaNGigw4cPa+bMmapQoYI++eQTValSRZ988ol1zssvv6xff/1VY8aMkZeXl958802FhYVZP4FLzyOPPCI3NzebZtXtEhMTdfDgQZUrV846FhISovr162vBggWSpA0bNuj48ePWT8wkWa9OGjduXLqfbMXGxip37tw2x7qXT8yyA1dX13THjX+sLzVhwgTt2rVLb7zxhq5du6YBAwaofPny+uOPPxwVJgAA923VqlU6deqU5s2bp9DQUOvj1npCd1rs24w7Xcn0z6ul/snT0zNN0yIlJUXNmjXTt99+q9dee01Lly5VbGysdYHw26+yzoxu3brp559/1h9//KHDhw9rw4YNmbrDWlhYmA4ePKjExMQ7ztm1a5fc3d1tPjTr1KmTVq9erXPnzikxMVHLli1Tu3btrM25W+fw9NNP37EWq1u3rs1xHsZarGPHjvr99981depUhYSEaNy4cSpfvry+++47R4UJZAqLfAO4o8DAQPn4+OjgwYNpth04cEAuLi4qUqSIdSxv3rzq2bOnevbsqcuXL6tBgwYaMWKEnn32WeucUqVKaeDAgRo4cKAOHTqkSpUqacKECfriiy/SjSFXrlxq3LixVq1apWPHjqlYsWJp5ixYsECJiYl64oknbMY7deqkfv366eDBg5o/f758fHzUsmVLm1ikm4s8RkRE3Ftyslh6Xy389ddf5ePjo8DAQEnK9M+iVKlS2rNnT5bGFx4ervDwcA0dOlTr169X3bp19cEHH+itt97K0uMAAJDV5syZowIFCmj69Olpti1evFhLlizRBx98IG9v70y9h5YqVUobN25UcnKy3N3d051z64rgCxcu2Iynd4fbO9m9e7d+/fVXffbZZ+rWrZt1/J936JVk/ep8Zt77O3furJiYGH355Ze6du2a3N3dbT58u5MnnnhCcXFxWrhwYboNqaNHj2rt2rWKiIiwaQB16tRJI0eO1FdffaWgoCAlJCSoc+fO1u2BgYHy9fVVSkqK02uxkydP6sqVKzZXMf3666+SZL0ZTbFixbRr1y6lpqbaNAQPHDhg3S7d/B354YcfdP78+UxdxZQZBQsWVL9+/dSvXz+dOXNGVapU0dtvv60WLVpkyesDWYErmADckaurq5o3b67//ve/1kuDpZt3+5g7d67q1atn/brZX3/9ZbNv7ty59cgjj1g/6bp69aquX79uM6dUqVLy9fXN8NMwSRo6dKgMw1CPHj3S3Jb3yJEj+te//qWCBQvafG9eunnXOldXV3355ZdauHChnnjiCZuioWrVqipVqpTGjx+vy5cvpznu2bNnM4wrK8XFxdmsMXDixAn997//VfPmzeXq6npPP4t27dpp586d6d6K2MjEne/+KSEhQTdu3LAZCw8Pl4uLy11/bgAAONu1a9e0ePFiPfHEE2rfvn2aR3R0tC5duqRly5ZJytx7aLt27XTu3DlNmzbtjnOKFSsmV1dXrVmzxmb7+++/n+nYb13Z8s/3bsMwNHnyZJt5gYGBatCggWbOnKnjx4+nG88t+fPnV4sWLfTFF19ozpw5ioqKsrm77J0899xzKlCggAYNGpTmq1nXr19Xz549ZRiGhg0bZrMtLCxM4eHhmj9/vubPn6+CBQuqQYMGNufYrl07ffXVV+k2yBxZi924cUMffvih9XlSUpI+/PBDBQYGWtfJfOyxxxQfH2/ztb8bN25o6tSpyp07t/Xri+3atZNhGBo5cmSa49xrLZaSkpJmaYICBQooJCSEWgwPHK5gAqCZM2fq+++/TzP+0ksv6a233lJsbKzq1aunfv36yc3NTR9++KESExM1duxY69xy5cqpUaNGqlq1qvLmzastW7ZYb6cq3fwEqGnTpurYsaPKlSsnNzc3LVmyRKdPn7b5JCs9DRo00Pjx4xUTE6NHH31UPXr0UMGCBXXgwAF9/PHHSk1N1fLly62fFt5SoEABNW7cWBMnTtSlS5fSfELn4uKiTz75RC1atFD58uXVs2dPFSpUSH/++adWr14tPz8/ff311/ebVknS2rVr0zTWpJsLOD766KPW5xUqVFBkZKQGDBggT09PawH6z8Iksz+LQYMGadGiRerQoYN69eqlqlWr6vz581q2bJk++OADVaxYMdPxr1q1StHR0erQoYNKly6tGzdu6D//+Y+1IAQA4EG2bNkyXbp0SU8++WS622vVqqXAwEDNmTNHnTp1ytR7aLdu3fT5558rJiZGmzZtUv369XXlyhWtWLFC/fr1U6tWreTv768OHTpo6tSpslgsKlWqlL755ps06wllpGzZsipVqpReffVV/fnnn/Lz89NXX32V7s1SpkyZonr16qlKlSrq27evSpQooaNHj+rbb7/Vjh07bOZ269ZN7du3lySNHj06U7Hky5dPixYt0uOPP64qVaro2WefVbly5RQfH6/Zs2frt99+0+TJk1WnTp00+3bq1EnDhg2Tl5eXevfuneargO+8845Wr16tmjVrqk+fPipXrpzOnz+vbdu2acWKFTp//nwmM5a+X3/9Nd0r5YOCgtSsWTPr85CQEL377rs6evSoSpcurfnz52vHjh366KOPrFeq9e3bVx9++KF69OihrVu3qnjx4lq0aJHWrVunSZMmWdefaty4sZ555hlNmTJFhw4dUlRUlFJTU7V27Vo1btzYWh9nxqVLl1S4cGG1b99eFStWVO7cubVixQpt3rxZEyZMMJUbIMs5/sZ1AB4Us2bNyvD2rSdOnDAMwzC2bdtmREZGGrlz5zZ8fHyMxo0bG+vXr7d5rbfeesuoUaOGERAQYHh7extly5Y13n77bettXc+dO2f079/fKFu2rJErVy7D39/fqFmzprFgwYJMx7tmzRqjVatWRv78+Q13d3ejaNGiRp8+fYyjR4/ecZ+PP/7YkGT4+voa165dS3fO9u3bjbZt2xr58uUzPD09jWLFihkdO3Y0Vq5caZ0zfPhwQ5Jx9uzZTMV661a6d3r883bAkoz+/fsbX3zxhREaGmp4enoalStXTnNrY8PI3M/CMAzjr7/+MqKjo41ChQoZHh4eRuHChY3u3btbbwF8K76FCxfa7Hf77ZN///13o1evXkapUqUMLy8vI2/evEbjxo2NFStWZCoPAAA4U8uWLQ0vLy/jypUrd5zTo0cPw93d3foeebf3UMMwjKtXrxpDhgwxSpQoYbi7uxvBwcFG+/btjcOHD1vnnD171mjXrp3h4+Nj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s2zGPD09nRQNAADAg43aCYA9cAUTgGzP09NTwcHBNo88efJIunkJ9owZM9SiRQt5e3urZMmSWrRokc3+u3fvVpMmTeTt7a18+fKpb9++unz5ss2cmTNnqnz58vL09FTBggUVHR1ts/3cuXNq06aNfHx8FBoaqmXLllm3/f333+ratasCAwPl7e2t0NDQNEUdAACAo1A7AbAHGkwAcrw333xT7dq1086dO9W1a1d17txZ+/fvlyRduXJFkZGRypMnjzZv3qyFCxdqxYoVNkXQjBkz1L9/f/Xt21e7d+/WsmXL9Mgjj9gcY+TIkerYsaN27dqlxx57TF27dtX58+etx9+3b5++++477d+/XzNmzFD+/PkdlwAAAIB7QO0E4L4YAJCNde/e3XB1dTVy5cpl83j77bcNwzAMScbzzz9vs0/NmjWNF154wTAMw/joo4+MPHnyGJcvX7Zu//bbbw0XFxcjPj7eMAzDCAkJMYYMGXLHGCQZQ4cOtT6/fPmyIcn47rvvDMMwjJYtWxo9e/bMmhMGAAAwgdoJgL2wBhOAbK9x48aaMWOGzVjevHmt/65du7bNttq1a2vHjh2SpP3796tixYrKlSuXdXvdunWVmpqqgwcPymKx6OTJk2ratGmGMTz66KPWf+fKlUt+fn46c+aMJOmFF15Qu3bttG3bNjVv3lytW7dWnTp17utcAQAAzKJ2AmAPNJgAZHu5cuVKc9l1VvH29s7UPHd3d5vnFotFqampkqQWLVro2LFjWr58uWJjY9W0aVP1799f48ePz/J4AQAA7obaCYA9sAYTgBxvw4YNaZ6HhYVJksLCwrRz505duXLFun3dunVycXFRmTJl5Ovrq+LFi2vlypWmYggMDFT37t31xRdfaNKkSfroo49MvR4AAIC9UDsBuB9cwQQg20tMTFR8fLzNmJubm3UxyIULF6patWqqV6+e5syZo02bNunTTz+VJHXt2lXDhw9X9+7dNWLECJ09e1YvvviinnnmGQUFBUmSRowYoeeff14FChRQixYtdOnSJa1bt04vvvhipuIbNmyYqlatqvLlyysxMVHffPONtUgDAABwNGonAPZAgwlAtvf999+rYMGCNmNlypTRgQMHJN28S8m8efPUr18/FSxYUF9++aXKlSsnSfLx8dEPP/ygl156SdWrV5ePj4/atWuniRMnWl+re/fuun79ut577z29+uqryp8/v9q3b5/p+Dw8PDR48GAdPXpU3t7eql+/vubNm5cFZw4AAHDvqJ0A2IPFMAzD2UEAgL1YLBYtWbJErVu3dnYoAAAADzxqJwD3izWYAAAAAAAAYAoNJgAAAAAAAJjCV+QAAAAAAABgClcwAQAAAAAAwBQaTAAAAAAAADCFBhMAAAAAAABMocEEAAAAAAAAU2gwAQAAAAAAwBQaTAAAAAAAADCFBhMAAAAAAABMocEEAAAAAAAAU/4PPlsiZCc36tkAAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 1400x500 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "F1 SCORE:  0.8311688311688312  | ACCURACY SCORE:  0.8581818181818182\n"
     ]
    }
   ],
   "source": [
    "with torch.no_grad():\n",
    "    test_outputs_tensor = model(X_test_tensor)\n",
    "    test_outputs = test_outputs_tensor.numpy()\n",
    "\n",
    "predicted = np.where(test_outputs > 0, 1, -1).flatten()\n",
    "\n",
    "c_matrix_display = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix(y_test, predicted))\n",
    "c_matrix_display.plot()\n",
    "\n",
    "epochs = range(1, len(train_loss_history) + 1)\n",
    "\n",
    "plt.figure(figsize=(14, 5))\n",
    "\n",
    "# Plot 1: Loss\n",
    "plt.subplot(1, 2, 1)\n",
    "plt.plot(epochs, train_loss_history, label='Train Loss', color='blue')\n",
    "plt.plot(epochs, test_loss_history, label='Test Loss', color='red', linestyle='--')\n",
    "plt.title('Loss Over Epochs')\n",
    "plt.xlabel('Epochs')\n",
    "plt.ylabel('Loss')\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "\n",
    "# Plot 2: Accuracy\n",
    "plt.subplot(1, 2, 2)\n",
    "plt.plot(epochs, acc_history, label='Test Accuracy', color='green')\n",
    "plt.title('Accuracy Over Epochs')\n",
    "plt.xlabel('Epochs')\n",
    "plt.ylabel('Accuracy')\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "\n",
    "plt.show()\n",
    "\n",
    "print(\"F1 SCORE: \", f1_score(y_test, predicted), \" | ACCURACY SCORE: \", accuracy_score(y_test, predicted))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/maria/AXION/.venv/lib/python3.12/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n",
      "  from .autonotebook import tqdm as notebook_tqdm\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Enter IQM Token:  /li6+n9MPCkM3nzAf4swx0MTn5n5drpqkTEUnumiy1MBnCfwDdV8co6o3BGS5c1s\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "No gradient function provided, creating a gradient function. If your Estimator requires transpilation, please provide a pass manager.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Connected to backend: IQMBackend\n",
      "Building Hardware QNN...\n",
      "Trained weights transferred to IQM model!\n"
     ]
    }
   ],
   "source": [
    "from iqm.qiskit_iqm import IQMProvider\n",
    "from qiskit_machine_learning.neural_networks import EstimatorQNN\n",
    "from qiskit_machine_learning.connectors import TorchConnector\n",
    "from qiskit.quantum_info import SparsePauliOp\n",
    "from qiskit import QuantumCircuit\n",
    "\n",
    "# 1. Connect to IQM\n",
    "\n",
    "try:\n",
    "    provider = IQMProvider(\"https://odra5.e-science.pl/\", token=input(\"Enter IQM Token: \"))\n",
    "    iqm_backend = provider.get_backend()\n",
    "    print(f\"Connected to backend: {iqm_backend.name}\")\n",
    "except Exception as e:\n",
    "    print(f\"Connection error: {e}\")\n",
    "\n",
    "# 2. Instantiate the Bridge\n",
    "\n",
    "hardware_estimator = IQMBackendEstimator(iqm_backend, options={\"shots\": 100})\n",
    "\n",
    "# 3. Re-create the QNN for Hardware\n",
    "print(\"Building Hardware QNN...\")\n",
    "\n",
    "# Reuse the same ansatz structure\n",
    "hw_ansatz = ansatz(4, 2)\n",
    "hw_feature_map = model.angle_encoding(4) \n",
    "\n",
    "hw_qc = QuantumCircuit(4)\n",
    "hw_qc.compose(hw_feature_map, qubits=range(4), inplace=True)\n",
    "hw_qc.compose(hw_ansatz, inplace=True)\n",
    "\n",
    "observable = SparsePauliOp.from_list([(\"I\" * 3 + \"Z\", 1)])\n",
    "\n",
    "# Create QNN with the HARDWARE ESTIMATOR\n",
    "hw_qnn = EstimatorQNN(\n",
    "    circuit=hw_qc,\n",
    "    observables=observable,\n",
    "    input_params=list(hw_feature_map.parameters),\n",
    "    weight_params=list(hw_ansatz.parameters),\n",
    "    estimator=hardware_estimator\n",
    ")\n",
    "\n",
    "# Create Torch Layer\n",
    "iqm_model = TorchConnector(hw_qnn)\n",
    "\n",
    "# 4. LOAD TRAINED WEIGHTS (CORRECTED LINE)\n",
    "iqm_model.load_state_dict(model.quantum_layer.state_dict())\n",
    "print(\"Trained weights transferred to IQM model!\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Sending job to IQM Spark for sample 67...\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Progress in queue:   0%|                                                                          | 0/1 [00:02<?, ?it/s]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "------------------------------\n",
      "IQM Raw Output:    -0.2200\n",
      "Predicted Class:   -1\n",
      "Actual Class:      -1\n",
      "------------------------------\n"
     ]
    }
   ],
   "source": [
    "# Select a sample from your test set\n",
    "# same samplw used in evauation of Simulator\n",
    "sample_idx = 67\n",
    "sample_input = X_test_tensor[sample_idx]\n",
    "actual_label = y_test_tensor[sample_idx].item()\n",
    "\n",
    "print(f\"Sending job to IQM Spark for sample {sample_idx}...\")\n",
    "\n",
    "with torch.no_grad():\n",
    "    # Pass input to the hardware model\n",
    "    prediction = iqm_model(sample_input)\n",
    "\n",
    "# Interpret result\n",
    "predicted_label = 1 if prediction.item() > 0 else -1\n",
    "\n",
    "print(\"-\" * 30)\n",
    "print(f\"IQM Raw Output:    {prediction.item():.4f}\")\n",
    "print(f\"Predicted Class:   {predicted_label}\")\n",
    "print(f\"Actual Class:      {int(actual_label)}\")\n",
    "print(\"-\" * 30)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "🚀 Sending job to IQM Spark...\n",
      "\n",
      "========================================\n",
      "        HARDWARE PERFORMANCE REPORT\n",
      "========================================\n",
      "Circuit Depth:      74\n",
      "SWAP Gates:         0  <-- (Target: 0)\n",
      "CZ Gates:           25\n",
      "----------------------------------------\n",
      "IQM Raw Output:     -0.2200\n",
      "Predicted Class:    -1\n",
      "Actual Class:       -1\n",
      "Confidence Level:   22.00%\n",
      "========================================\n"
     ]
    }
   ],
   "source": [
    "from qiskit import transpile\n",
    "import torch\n",
    "\n",
    "def get_circuit_stats(circuit, backend):\n",
    "    # Transpile to see how the hardware actually executes it\n",
    "    t_qc = transpile(circuit, backend, optimization_level=3)\n",
    "    ops = t_qc.count_ops()\n",
    "    return {\n",
    "        'Depth': t_qc.depth(),\n",
    "        'SWAPs': ops.get('swap', 0),\n",
    "        'CNOTs/CZs': ops.get('cz', 0) + ops.get('cx', 0)\n",
    "    }\n",
    "\n",
    "# --- FIX 1: Access the circuit correctly via .neural_network.circuit ---\n",
    "# --- FIX 2: Use 'iqm_backend' instead of 'backend' ---\n",
    "qnn_circuit = iqm_model.neural_network.circuit\n",
    "stats = get_circuit_stats(qnn_circuit, iqm_backend)\n",
    "\n",
    "# 2. Select sample\n",
    "sample_idx = 67\n",
    "sample_input = X_test_tensor[sample_idx]\n",
    "actual_label = y_test_tensor[sample_idx].item()\n",
    "\n",
    "print(f\"🚀 Sending job to IQM Spark...\")\n",
    "\n",
    "with torch.no_grad():\n",
    "    prediction = iqm_model(sample_input)\n",
    "\n",
    "# Logic: If output > 0 class is 1, else -1 (Adjust based on your specific labels)\n",
    "predicted_label = 1 if prediction.item() > 0 else -1\n",
    "\n",
    "# --- FINAL COMPARISON TABLE ---\n",
    "print(\"\\n\" + \"=\"*40)\n",
    "print(f\"        HARDWARE PERFORMANCE REPORT\")\n",
    "print(\"=\"*40)\n",
    "print(f\"Circuit Depth:      {stats['Depth']}\")\n",
    "print(f\"SWAP Gates:         {stats['SWAPs']}  <-- (Target: 0)\")\n",
    "print(f\"CZ Gates:           {stats['CNOTs/CZs']}\")\n",
    "print(\"-\" * 40)\n",
    "print(f\"IQM Raw Output:     {prediction.item():.4f}\")\n",
    "print(f\"Predicted Class:    {predicted_label}\")\n",
    "print(f\"Actual Class:       {int(actual_label)}\")\n",
    "print(f\"Confidence Level:   {abs(prediction.item()):.2%}\")\n",
    "print(\"=\"*40)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "\n",
    "def evaluate_estimator_sample(model, input_tensor, true_label_tensor):\n",
    "    model.eval()\n",
    "    if input_tensor.dim() == 1:\n",
    "        input_batch = input_tensor.unsqueeze(0)\n",
    "    else:\n",
    "        input_batch = input_tensor\n",
    "\n",
    "    start_time = time.perf_counter()\n",
    "    \n",
    "    with torch.no_grad():\n",
    "        output = model(input_batch)\n",
    "        \n",
    "    end_time = time.perf_counter()\n",
    "    \n",
    "    time_taken = end_time - start_time\n",
    "    \n",
    "    expectation_value = output.item()\n",
    "    predicted_label = 1.0 if expectation_value > 0 else -1.0\n",
    "    true_label = true_label_tensor\n",
    "\n",
    "    return {\n",
    "        \"expectation_value\": expectation_value,\n",
    "        \"predicted_label\": predicted_label,\n",
    "        \"true_label\": true_label,\n",
    "        \"time_seconds\": time_taken\n",
    "    }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "------------------------------\n",
      "Single Forward Pass (Sample 67)\n",
      "------------------------------\n",
      "Expectation Value: -0.600909\n",
      "Predicted Label:   -1.0\n",
      "True Label:        -1.0\n",
      "Time Taken:        0.0163581190 sec\n",
      "------------------------------\n"
     ]
    }
   ],
   "source": [
    "results = evaluate_estimator_sample(model, sample_input, actual_label)\n",
    "\n",
    "# Print the results\n",
    "print(\"-\" * 30)\n",
    "print(f\"Single Forward Pass (Sample {sample_idx})\")\n",
    "print(\"-\" * 30)\n",
    "print(f\"Expectation Value: {results['expectation_value']:.6f}\")\n",
    "print(f\"Predicted Label:   {results['predicted_label']}\")\n",
    "print(f\"True Label:        {results['true_label']}\")\n",
    "print(f\"Time Taken:        {results['time_seconds']:.10f} sec\")\n",
    "print(\"-\" * 30)"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "include_colab_link": true,
   "name": "quantum_classifier.ipynb",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python (IQM Spark)",
   "language": "python",
   "name": "my_iqm_env"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
